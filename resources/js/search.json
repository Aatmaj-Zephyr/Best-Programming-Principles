[[{"l":"Best-Programming-Principles","p":["This is a repository which contains blogs related to best coding and programming practices"]}],[{"l":"5 proverbs for rapid development"},{"i":"let-us-see-five-proverbs-which-fit-perfectly-to-the-rapid-development-scenario","l":"Let us see five proverbs which fit perfectly to the rapid development scenario."},{"i":"an-ounce-of-protection-is-worth-a-pound-of-cure","l":"An ounce of protection is worth a pound of cure.","p":["A little precaution before a crisis hits is better than lot of firefighting afterwards. Many times, developers neglect risk management. Risk management, identification and prevention are more critical than we think. Unidentified risks cause a lot of trouble in the later stages of software development. This is why, preventing such risks is wiser than to fix them after they get worsened. Identifying risks and taking precautions against them, that is protecting the project against the risk is a key to rapid development."]},{"l":"A stich in time saves nine","p":["Correction at early stages saves work later. In a software development lifecycle, doing right things at the right time is very important. If work is delayed in the earlier stages, it can causes much trouble afterward. Example a flaw in the design time is not fixed is bound to cause a disaster. And one flaw in the implementation time if not fixed will take almost triple the time to fix at the debugging phase."]},{"i":"cross-the-stream-where-it-is-shallowest","l":"Cross the stream where it is shallowest.","p":["Don't complicate things unnecessarily. Many developers believe that the more complicated things will be made, the better the project will execute. But that's not the case. In reality complicated practices, stringent methodologies actually lengthen the process rather than making it faster. This is why many times the simple is the best. Complex design patters, complex code leads only to increasing the clutter of the program. Yes, this doesnt mean that one must nor use complex patterns or code. This means that one must always strive for a simpler solution to the problem."]},{"i":"watch-the-doughnut-and-not-the-hole","l":"Watch the doughnut, and not the hole.","p":["Focus on what you have rather than at what you don't. In a software development lifecycle, one cannot get all the aspects perfect. In that case, you need to maximize what you have over what you don't. For example you might not have trained personnel, or say might not have enough time. But in such cases, you must focus on what you have and try to give the best possible. Focus on your strengths and try to win the match."]},{"i":"too-many-cooks-spoil-the-broth","l":"Too many cooks spoil the broth.","p":["If too many people are involved in a task or activity, it will not be done well. This is often the case with software development scenarios. Too many people who are experienced and have their own different viewpoints. While difference in perspectives always leads to better ideas, there must be only one decision maker whome everyone must follow. Disagree but commit must be the case with those who are the subordinates. If too many people are decision makers, then it will lead to chaos."]}],[{"l":"Best Coding Practices"},{"i":"best-coding-practices","l":"Best coding practices.","p":["Always name your variables and functions with the utmost care and explain them thoroughly.","Keep documentation concise but descriptive.","The reading time for programs is much more than the writing time. Hence, the code must be such that the reading is easier to do. A little more time spent in making the code lucid goes a long way in saving time later.","Each function must do only one task but do it well.","Treat each function as a BlackBox- each function must hide something.","Keep the connections simple. Avoid global variables wherever possible.","If you use global variables, document them thoroughly. Not doing so will cause side effects.","The quality of the test data is more important than its quantity.","Program testing can show the presence of bugs, but never their absence. You cannot ever guarantee 100% correct code.","Adapted from the book Data Structures and Program Design in C"]}],[{"l":"Best Coding Practices part 2"},{"i":"best-coding-practices-to-remember","l":"Best coding practices to remember.","p":["Be sure to understand your problem before you decide how to solve it.","Be sure you understand the algorithmic method before you start the program","In case of difficulty, divide the problem into pieces and think of each part separately. (Divide and conquer)","Keep your functions short and simple; rarely should a single function be more than a page long.","Use techniques like \"scaffolding\" to simplify debugging. Scaffolding is a technique used to localize errors.","Keep your programs well formatted as you write them. This makes debugging easier.","Keep your documentation consistent with your code, and when reading a program make sure you debug he code and not just the comments.","Explain your program to someone else: Doing so will help you understand it better yourself.","Adapted from the book Data Structures and Program Design in C"]}],[{"l":"Code and fix model A recipe for disaster","p":["The study of development models cannot be complete unless we include the traditional - code and fix model. It is a model (or rather a lack of model) which is easy, but useless if rapid development is to be achieved. Although no one uses it today, understanding what it was highlights the practicality of the development models we use. So rather this blog should have been titled \"benefits of development models\"","Here presenting adaptations from the book Rapid Development: Taming Wild Software Schedules by Steve McConnell","If you have not done any project planning or chosen another lifecycle model, then you undoubtedly use this 'model' Combined with a short-schedule, which is the case most of the times, this model gives rise to code-like-hell approach. The code like hell approach is an approach which makes people work until either they or the project has been finished.","When you use the code and fix model, you start with a general idea of what you want to build. You might have a formal specification. You then use whatever combination of informal design, code, debug and test methodologies suits you until you have a product ready to release.","WhatsApp Image 2021-10-04 at 9.46.37 AM","The code and fix model has two advantages. First, it has no overhead: You don't spend nay time on planning, documentation, quality assurance, standered enforcements, or any activities other than pure coding. Since you jump right into coding, you can show signs of progress immediately. Second it requires a very little expertise: anyone who has ever written a computer program is familiar with the code and fix model.","For tiny projects that you intend to throw away after they're built, this model can be useful-for small proof-of-concept programs, for short-lived demos, or throwaway prototypes","For any kind of projects other than a tiny project, this model is dangerous. It might have no overhead, but it also provides no means of accessing progress- You just code until you are done. It provides no means of accessing quality or identifying risks. If you discovered three quarters of the way through coding that your whole design approach is fundamentally flawed, you have to throw the work you have done and start over again. Other models would set you up to detect such a fundamental mistake earlier, when it would have been less costly to fix."]}],[{"l":"CONTRIBUTING","p":["Please feel free to contribute"]}],[{"l":"Contributor Covenant Code of Conduct"},{"l":"Our Pledge","p":["We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community."]},{"l":"Our Standards","p":["Examples of behavior that contributes to a positive environment for our community include:","Demonstrating empathy and kindness toward other people","Being respectful of differing opinions, viewpoints, and experiences","Giving and gracefully accepting constructive feedback","Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience","Focusing on what is best not just for us as individuals, but for the overall community","Examples of unacceptable behavior include:","The use of sexualized language or imagery, and sexual attention or advances of any kind","Trolling, insulting or derogatory comments, and personal or political attacks","Public or private harassment","Publishing others' private information, such as a physical or email address, without their explicit permission","Other conduct which could reasonably be considered inappropriate in a professional setting"]},{"l":"Enforcement Responsibilities","p":["Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.","Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate."]},{"l":"Scope","p":["This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event."]},{"l":"Enforcement","p":["Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at Gmail. All complaints will be reviewed and investigated promptly and fairly.","All community leaders are obligated to respect the privacy and security of the reporter of any incident."]},{"l":"Enforcement Guidelines","p":["Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:"]},{"l":"1. Correction","p":["Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.","Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested."]},{"l":"2. Warning","p":["Community Impact: A violation through a single incident or series of actions.","Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban."]},{"l":"3. Temporary Ban","p":["Community Impact: A serious violation of community standards, including sustained inappropriate behavior.","Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban."]},{"l":"4. Permanent Ban","p":["Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.","Consequence: A permanent ban from any sort of public interaction within the community."]},{"l":"Attribution","p":["This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.","Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.","For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."]}],[{"l":"Modified waterfalls","p":["One most significant problems with the pure waterfall model from a rapid development point of view are that you're supposed to be completely done with an architectural design before you begin with a detailed design, and you're supposed to be completely done with the detailed design before you begin coding and debugging. However, in the practical world, systems do have areas that contain design surprises, but they have other areas that we have implemented many times before and contain no surprises. Delaying the implementation of the areas that are easy to design just because the design of a difficult area is pending is not a good idea. If the architecture has broken the system into a logically independent system, you can spin off separate projects, each of which can proceed at its own pace.","This is what is called as the waterfall with sub-projects model. In this model, the waterfall is broken into different parts and the subprojects are executed independently into waterfall streams. Image description"]},{"l":"The main risk","p":["This model a very vulnerable risk, that is unforeseen interdependencies. You can partly account for that by removing dependencies at the architecture time or waiting until detailed design time to break the project into subprojects. Careful planning can allow you to perform some of the waterfall's task in parallel.","Notes and images from Rapid Development: Taming Wild Software Schedules by Steve McConnell"]}],[{"i":"practical-tips-for-constructing-object-diagrams-from-applications","l":"Practical tips for constructing Object diagrams from applications.","p":["Don't begin constructing an object by merely jotting down classes and inheritance. Understand the problem first. The content of an object model is driven by it's relevance.","Keep the model as simple as possible. Avoid needless complications.","Carefully choose names. Choosing the right name is one of the most difficult step in object oriented design. Choosing the right names not only avoids confusion but also improves the clarity in the program structure. Names should be descriptive, crisp, and unambiguous. Names should not be biased with only a certain aspect of the object, but rather have an comprehensive way of approach.","Try to avoid too deep nested generalizations","Don't be surprised if your object diagram requires revision. Object models often require multiple iterations to clarify names, repair errors, add details and correctly capture structural constraints.","Try to get others review your model. Object models can be a focal point for stimulating the involvement of others.","Always document your object models. The object diagrams specify the structure of a model but cannot describe the reasons behind it. The written explaination guides the reader through the model and explains the subtle reasons why the model was structured in the particular way. It clarifies the meaning of the names in the model and should convey the reason for each class and relationship.","Adapted from the book Object - Oriented Modeling and Design"]}],[{"l":"Principles of Extreme Programming XP","p":["Xp is based on a set of proven practices that are all designed to work together, although many folks do pick and choose, and adopt only a portion of XP's rules","Here are a few practices.","Make small, but frequent releases.","Develop in iteration cycles and not in big-bang models","Don't put anything that is not in the spec, no matter how tempted you to put in functionality for the future.","Write the test code first","No killer schedules, work regular hours","Refactor (improve the code) whenever and wherever you notice the opportunity","Don't release anything until it passes all tests","Set realistic schedules, based around small releases.","Keep it simple","Program in pairs, and move people around so that everybody knows pretty much everything about code.","Adapted from the book Headfirst Java"]}],[{"l":"Principles of good software design","p":["Most programs spend their 90% time doing 10% instructions. Find this 10% and concentrate your efforts there.","Never code until specifications are precise and complete.","Sometimes postponing (algorithmic) problems simplifies their solution, just like it happens in recursive algorithms.","Choose the algorithm wisely according to the need. Unnecessary complication of algorithm doubles up the work. Dont choose a algorithm just because you know it. Keep your logic simple!","Keep your algorithms as simple as you can. When in doubt, choose the simple way","Consider time and space tradeoffs while deciding your algorithm.","Be sure that the algorithm is correct before starting to code. For this, make a throwaway prototype and test the algorithm. At least verify the intricate parts of the algorithm.","If >40% code of a module gives errors, Rewrite the entire module again. Never be afraid to start over. Next time may be both shorter and easier than patchwork and bug-fixing. Starting afresh is easier than patching an old program","Act in haste and repent at leisure. Program in haste and debug forever!","Never optimize a program until it is correct and working.","Don't optimize code unless absolutely necessary.","Adapted from the book Data Structures and Program Design in C"]}],[{"l":"Quality Assurance fundamentals"},{"l":"Introduction","p":["Prevention is better than cure. Not installing defects in the first place is better than debugging. This can be achieved only through paying attention to quality assurance fundamentals from Day 0 of your project. WhatsApp Image 2021-09-20 at 10 25 37 AM"]},{"i":"does-poor-quality-hit","l":"Does poor quality hit?","p":["After surveying 4000 projects, it is found that poor quality is one of the most common reasons for schedule overruns. Poor quality is the reason for half of the cancelled projects.","Here is how time and effort are lost due to bad quality.","The original effort spent designing and implementing the 'bad quality code' or 'cut-the-corners-short code' is wasted, because sooner or later the entire code will be thrown away.","By writing a bad code, you are postponing the problem to later. Time spent unit-testing and debugging the code is down the drain. At a later time of the project, either the bad module will have to be replaced, or worse- scattered with patchwork","Additional time will be spent to strip the bad module out of the main code and modify it. Additional testing and debugging time will be spent to ensure that the modified code still works.","Time will be spent in the design and implementation of the entire code due to changes in the bad module. the new code, which should have been designed as an integral part of the system has to be designed around the system.","All this could have been prevented if necessary steps would have been taken to ensure a good-quality code from the start."]},{"i":"a-stitch-in-time-saves-nine","l":"A stitch in time saves nine.","p":["If you can prevent defects or detect and remove them early, you can realize significant schedule benefits. Studies have found out that reworking defective requirements, design and code typically consumes 40-50% of the total cost of software development. Requirements defect that is left undetected until construction or maintenance will cost 50 to 200 times more than at requirements time. If a defect is not detected in the early stages, it becomes a time bomb later, with 10-100 times much more effort to fix.","WhatsApp Image 2021-09-20 at 10 49 01 AM","The longer defects remain undetected, the longer they take to fix. Correct defects while they are young and easy to control"]},{"i":"prevention-is-better-than-cure","l":"Prevention is better than cure.","p":["Every hour you spend on defect prevention will reduce your repair time by 4-5 hours. So the key to success is to implement practices that prevent the errors rather than fix them. An error-prone module is the one that is responsible for a majority of the bugs. 20% modules are responsible for 80% of bugs. Prevent the existence of such modules by using the practises given below."]},{"l":"Practises to prevent errors","p":["Testing Testing is the black sheep of QA. It is the messenger of disaster to the management. But the best way to tackle it is to plan ahead for the bad news. Deliver it as early as possible. Unit testing, where the developer checks their own code to verify if it works correctly has effectiveness in the range 10-60. System testing, in which an independent tester checks the system operation has an effectiveness of 20-60%","Technical walkthrough Walkthrough is a method by which two or more reviewers review technical work to improve quality. Walkthroughs can find between 30-70 per cent of errors in a program. Such inspections are very effective when performed in the early stages and each hour spent in inspection saves 20 hours of maintenance overhead.","Code reading In code reading, two or more reviewers (except for the author) review the code. This method is very effective and finds twice the number of defects per hour than testing.","Code review Code reviews are the most cost-effective on a per0defect basis. This is because they detect both the symptom of the defect and the underlying cause at the same time. Testing detects only the symptom of the defect and not the cause, and the developer still has to find the root cause of the defect. They not only tend to find a higher percentage of defects but also provide a forum for developers to share their knowledge of best practices with each other, which increases their rapid development over time. Thus, technical reviews are a critical component of any development effort that is trying to achieve the shortest possible schedule.","Notes from Rapid Development: Taming Wild Software Schedules by Steve McConnell"]}],[{"l":"Spiral lifecycle model Part 1","p":["After all the risks have been addressed, the waterfall model terminates as a waterfall lifecycle would.","Cinnamon roll","Commit to an approach for the next iteration.","Determine objectives, alternatives, and constraints.","Each iteration involves the six steps below","Each iteration moves the project into a larger scale. You roll up one layer of the cinnamon roll, check to be sure that it's what's you wanted., and then you begin work for the next layer.","Evaluate alternatives","identify and resolve risks","In the spiral model, the early decisions are the cheapest. You spend less developing the concept of operation than you do developing the requirements than you do developing the design, implementing the product, and testing it.","Notes and images from Rapid Development: Taming Wild Software Schedules by Steve McConnell","Plan the next iteration.","Poorly understood architecture","Poorly understood requirements","Potential requirement problems","Problems in underlying technology.","the basic idea about the diagram is that you start on a small scale in the middle of the spine, explore the risks make a plan to handle the risks, and then commit to an approach for the next iteration.","The spiral model is a risk oriented model that breaks a software project up into mini projects. Each mini-project addresses one or more major risks until al the major risks have been addressed. Risks refers to factors like","The spiral model is also called as the 'cinnamon roll' model.","The spiral model of development is a really good model that helps you develop faster. In the spiral model, you start small and expand the scope of the project in increments. You expand the scope only after you have reduced the risks for the next increment to an acceptable level. Today let us learn more about this model","To be continued...","You can tailor the iterations of the model as per your requirements and the needs of the project."]}],[{"l":"Spiral lifecycle model Part 2","p":["In the last post, we studied about the spiral lifecycle model. Let us now continue discussing about the model in this part. Just in case you missed it, you can check it out here"]},{"l":"Advantages of the model","p":["The spiral lifecycle model helps you analyze risks and eliminate them before they get too big. One of the moist important advantages of the spiral model is that as the cost increases, the risk decreases. The more time and money you spend, the lesser risk you are actually taking, which is exactly what we all want in any lifecycle model.","The spiral model provides at least as much management control as the traditional waterfall model, you have the checkpoints ready just from the start of every iteration. Because the model is risk oriented, it provides you with the early indications of any risks possible. If in the worst case, the project cant be done for technical or any other reasons, you will find that out early on. Moreover the users can see the system easily from the start due to effective prototyping. This results in Early user engagement","The spiral lifecycle model can be coupled with other lifecycle models in a couple of different ways. This is why this model is very adaptable. And yes, the transition from building a project to maintaining it is so smooth that this boosts the overall maintainability of the project"]},{"l":"Disadvantages","p":["The only disadvantage of the spiral model is that it's a lot complicated. It requires conscientious, attentive and knowledgeable management. It can be difficult to define objective, verifiable milestones that indicate weather you're ready to add the next layer to the model or not. In some cases, the product development is straight forward enough and project risks are modest enough that you don't need the flexibility and risk management provided by the spiral model. Not suitable for small or low risk projects and could be expensive for small projects."]},{"l":"When to use this model","p":["Use this model when you have an experienced management staff. Use in projects where user involvement is to be preferred over expected time to complete.","Use For"]},{"i":"for-medium-to-high-risk-projects","l":"For medium to high-risk projects."},{"i":"when-there-is-adequate-to-fair-time","l":"When there is adequate to fair time."}],[{"l":"Sashimi Waterfall model of development","p":["The name Sashimi comes from the Japanese style of presenting raw fish, where the slices overlap each other. In the sashimi model, too the stages overlap each other to overcome the drawbacks of the traditional waterfall development model.","The sashimi model of development is a modification to the traditional waterfall model.","The traditional waterfall provides minimal overlapping between the two stages of development. Doesn't But that s not the case with the Sashimi model of development.","This model suggests a stronger degree of overlap between the stages-For example, suggesting you might be well into architectural design partway between the structural analysis and perhaps partway into the detailed designing before you consider requirements analysis to ve complete. This is a reasonable approach for many projects, which tend t gain important insights into what they are doing as they move through their development cycles and which function poorly with their strictly sequential development plans. In the pure waterfall model, the ideal documentation is that one team can to a completely separate team between any two phases. The question is, \"why?\" If you can provide personnel continuity between all stages of software development, you don't need much documentation. This wa, by following modified waterfall model, you can substantially reduce the need for documentation.","Image description"]},{"i":"the-disadvantages","l":"The disadvantages.","p":["The Sashimi model is no without problems. Because there is an overlap between the phases, milestones are more ambiguous, and it's harder to track progress accurately. Performing activities in parallel can lead to miscommunication, mistaken assumptions and result in inefficiency. If you are working on a small, well-defined project, something close to the pure waterfall can be more efficient instead.","Notes and images from Rapid Development: Taming Wild Software Schedules by Steve McConnell"]}],[{"l":"The waterfall development model","p":["In the waterfall model, a project progresses through an orderly sequence of steps from the initial software concept through system testing. The project holds a review at the end of each stage to determine whether it is ready to advance to the next phase. If not, it remains in the same phase. WhatsApp Image 2021-09-27 at 9.32.39 AM","The pure waterfall model performs well for product cycles in which you have a stable product defination and when you are working with well understood technical methodologies. In such cases, the waterfall model helps you to find out errors in the early, low cost stages of the product. It provides the requirements stability that developers crave. If you are building a well defined maintenance release of an existing product or porting an existing product to a new platform, a waterfall lifecycle might be the right choice for rapid development","The pure waterfall model helps to minimize planning overhead because you can do all the planning up front. It doesn't provide tangible results in the form of software until the end of the lifecycle, but to someone who is familiar with it, the documentation it generates provides meaningful indications of progress throughout the lifecycle. The waterfall model works well for projects that are well defined, well understood and complex, because you can benifit from tackling complexity in an orderly way. It works well when quality requirements dominate cost and schedule requirements. Elimination of midstream changes eliminates a huge and common source of potential errors.","The waterfall model works especially well if you have a technically weak staff or an inexperienced staff, because it provides the project with a structure that helps to minimize wasted effort.","The disadvantages of the pure waterfall model arise from the difficulty of fully specifying requirements at the beginning of the project, before any design work has been done and before any code has been written.","The major problem with the waterfall model is that it is not flexible. You have to fully specify the requirements at the beginning of the project.","Notes and images from Rapid Development: Taming Wild Software Schedules by Steve McConnell"]}]]